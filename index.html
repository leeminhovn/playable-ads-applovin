<!DOCTYPE html>
<html lang="vi">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Puzzle Block Game</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/7.2.4/pixi.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background: linear-gradient(135deg, #c2185b 0%, #8e24aa 100%);
            font-family: 'Arial', sans-serif;
            padding: 10px;
        }

        .container {
            background: #c2185b;
            border-radius: 15px;
            padding: 15px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.8);
            border: 4px solid #4a148c;
            width: 100%;
            max-width: 600px;
            aspect-ratio: 1 / 1.2;
            display: flex;
            flex-direction: column;
        }

        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            background: linear-gradient(90deg, #00695c 0%, #004d40 50%, #1976d2 100%);
            padding: 8px 15px;
            border-radius: 10px;
            border: 3px solid #4a148c;
            flex-wrap: wrap;
            gap: 10px;
        }

        .stats {
            display: flex;
            gap: 20px;
            font-size: 14px;
            font-weight: bold;
        }

        .stat-item {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .stat-label {
            color: #fff;
            font-size: 11px;
            background: rgba(0, 0, 0, 0.3);
            padding: 2px 6px;
            border-radius: 3px;
        }

        .stat-value {
            color: #FFD700;
            font-size: 18px;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
        }

        .progress-section {
            display: flex;
            flex-direction: column;
            gap: 3px;
        }

        .progress-wrapper {
            position: relative;
            width: 280px;
        }

        .progress-bar {
            width: 100%;
            height: 28px;
            background: #000;
            border-radius: 14px;
            overflow: hidden;
            border: 3px solid #4a148c;
            position: relative;
            display: flex;
        }

        .progress-segment {
            height: 100%;
            transition: width 0.3s ease;
        }

        .progress-green {
            background: linear-gradient(90deg, #00e676 0%, #76ff03 100%);
        }

        .progress-black {
            background: #000;
        }

        .progress-blue {
            background: linear-gradient(90deg, #1e88e5 0%, #42a5f5 100%);
        }

        .progress-labels {
            position: absolute;
            top: 50%;
            left: 0;
            right: 0;
            transform: translateY(-50%);
            display: flex;
            justify-content: space-between;
            padding: 0 12px;
            pointer-events: none;
        }

        .progress-label {
            font-size: 13px;
            font-weight: bold;
            color: #FFD700;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
        }

        .progress-center {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 14px;
            font-weight: bold;
            color: #FFD700;
            text-shadow: 1px 1px 3px rgba(0, 0, 0, 0.9);
        }

        .game-wrapper {
            flex: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
        }

        #gameContainer {
            position: relative;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        #gameCanvas {
            display: block;
            max-width: 100%;
            max-height: 100%;
        }

        .info {
            margin-top: 10px;
            font-size: 11px;
            color: #fff;
            text-align: center;
            font-weight: bold;
        }
    </style>
</head>

<body>
    <div class="container">
        <div class="header">
            <div class="stats">
                <div class="stat-item">
                    <span class="stat-label">ƒêi·ªÉm:</span>
                    <span class="stat-value" id="score">0</span>
                </div>
                <div class="stat-item">
                    <span class="stat-label">Level:</span>
                    <span class="stat-value" id="level">1</span>
                </div>
            </div>
            <div class="progress-section">
                <div class="progress-wrapper">
                    <div class="progress-bar" id="progressBar">
                        <div class="progress-segment progress-green" id="progressGreen"></div>
                        <div class="progress-segment progress-black" id="progressBlack"></div>
                        <div class="progress-segment progress-blue" id="progressBlue"></div>
                    </div>
                    <div class="progress-labels">
                        <span class="progress-label" id="prevMilestone">0</span>
                        <span class="progress-label" id="nextMilestone">500</span>
                    </div>
                    <div class="progress-center" id="currentScore">0</div>
                </div>
            </div>
        </div>

        <div class="game-wrapper">
            <div id="gameContainer">
                <div id="gameCanvas"></div>
            </div>
        </div>
    </div>

    <script>
        // ==================== CONFIG ====================
        const CONFIG = {
            BOARD_COLS: 8,
            BOARD_ROWS: 8,
            CELL_SIZE: 50,
            CELL_PADDING: 4,
            CELL_BORDER_WIDTH: 3,
            CELL_BORDER_RADIUS: 8,
            CELL_COLORS: ['#FF6B35', '#F7931E', '#FDC830', '#4ECDC4', '#95E1D3'],
            CELL_BORDER_COLOR: '#3d2817',
            EMPTY_CELL_BG: '#1a0f0a',
            EMPTY_CELL_BORDER: '#3d2817',
            LEVEL_MILESTONES: [0, 500, 1000, 1500, 2000],
            USE_BASE64_ICONS: true,
            CELL_ICONS_BASE64: [
                'data:image/png;base64,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',
                'data:image/png;base64,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',
                'data:image/png;base64,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',
                'data:image/png;base64,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',
                'data:image/png;base64,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'
            ],
            CELL_ICONS_EMOJI: ['üíé', 'üåü', 'üé®', 'üéØ', 'üî•'],
            BLOCK_SHAPES: [
                [[0, 0], [1, 0], [2, 0], [3, 0]],
                [[0, 0], [0, 1], [0, 2], [0, 3]],
                [[0, 0], [1, 0], [0, 1], [1, 1]],
                [[0, 0], [1, 0], [2, 0], [1, 1]],
                [[0, 0], [0, 1], [0, 2], [1, 2]],
                [[1, 0], [1, 1], [1, 2], [0, 2]],
                [[0, 0], [1, 0], [1, 1], [2, 1]],
                [[1, 0], [2, 0], [0, 1], [1, 1]],
                [[0, 0]],
                [[0, 0], [1, 0], [0, 1], [1, 1], [2, 0]],
                [[0, 0], [1, 0], [2, 0]],
                [[0, 0], [0, 1], [0, 2]],
                [[0, 0], [1, 0]],
                [[0, 0], [0, 1]],
                [[0, 0], [1, 0], [2, 0], [3, 0], [4, 0]]
            ]
        };

        // ==================== CELL CLASS ====================
        class GameCell {
            constructor(type = -1) {
                this.type = type;
                this.graphic = null;
            }
            renderHighlightGreen() {
                const { CELL_SIZE, CELL_PADDING, CELL_BORDER_WIDTH, CELL_BORDER_RADIUS } = CONFIG;

                const newGraphic = new PIXI.Graphics();
                const innerSize = CELL_SIZE - CELL_PADDING * 2;
                const innerX = CELL_PADDING;
                const innerY = CELL_PADDING;

                // Padding: gradient xanh
                const gradientTexture = this.createGradientTexture(CELL_SIZE, CELL_SIZE, '#2E7D32', '#00C853');
                newGraphic.beginTextureFill({ texture: gradientTexture });
                newGraphic.drawRoundedRect(0, 0, CELL_SIZE, CELL_SIZE, CELL_BORDER_RADIUS);
                newGraphic.endFill();

                // Background: xanh
                newGraphic.beginFill(0x00FF00);
                newGraphic.drawRoundedRect(innerX, innerY, innerSize, innerSize, CELL_BORDER_RADIUS);
                newGraphic.endFill();

                // Border gi·ªØ m·∫∑c ƒë·ªãnh
                newGraphic.lineStyle(CELL_BORDER_WIDTH, parseInt(CONFIG.CELL_BORDER_COLOR.slice(1), 16));
                newGraphic.drawRoundedRect(0, 0, CELL_SIZE, CELL_SIZE, CELL_BORDER_RADIUS);

                // Gi·ªØ icon theo lo·∫°i
                const icon = this.createIcon(this.type);
                icon.position.set(CELL_SIZE / 2, CELL_SIZE / 2);
                newGraphic.addChild(icon);

                this.graphic = newGraphic;
                return newGraphic;
            }
            render() {
                const { CELL_SIZE, CELL_PADDING, CELL_BORDER_WIDTH, CELL_BORDER_RADIUS } = CONFIG;

                const newGraphic = new PIXI.Graphics();
                const innerSize = CELL_SIZE - CELL_PADDING * 2;
                const innerX = CELL_PADDING;
                const innerY = CELL_PADDING;

                if (this.type === -1) {
                    // Gi·ªØ nguy√™n k√≠ch th∆∞·ªõc ƒë·∫ßy ƒë·ªß cho cell empty, kh√¥ng tr·ª´ padding
                    newGraphic.beginFill(parseInt(CONFIG.EMPTY_CELL_BG.slice(1), 16));
                    newGraphic.lineStyle(CELL_BORDER_WIDTH, parseInt(CONFIG.EMPTY_CELL_BORDER.slice(1), 16));
                    newGraphic.drawRoundedRect(0, 0, CELL_SIZE, CELL_SIZE, CELL_BORDER_RADIUS);
                    newGraphic.endFill();
                } else {
                    // T·∫°o gradient texture cho padding layer (t·ª´ xanh t·ªõi ƒë·ªè, vertical)
                    const gradientTexture = this.createGradientTexture(CELL_SIZE, CELL_SIZE, '#0000FF', '#FF0000'); // Xanh: blue, ƒê·ªè: red

                    // V·∫Ω outer v·ªõi gradient fill
                    newGraphic.beginTextureFill({ texture: gradientTexture });
                    newGraphic.drawRoundedRect(0, 0, CELL_SIZE, CELL_SIZE, CELL_BORDER_RADIUS);
                    newGraphic.endFill();

                    // V·∫Ω inner background solid color l√™n tr√™n ƒë·ªÉ t·∫°o padding gradient visible ch·ªâ ·ªü vi·ªÅn
                    const colorHex = parseInt(CONFIG.CELL_COLORS[this.type].slice(1), 16);
                    newGraphic.beginFill(colorHex);
                    newGraphic.drawRoundedRect(innerX, innerY, innerSize, innerSize, CELL_BORDER_RADIUS);
                    newGraphic.endFill();

                    // V·∫Ω border l√™n tr√™n c√πng
                    newGraphic.lineStyle(CELL_BORDER_WIDTH, parseInt(CONFIG.CELL_BORDER_COLOR.slice(1), 16));
                    newGraphic.drawRoundedRect(0, 0, CELL_SIZE, CELL_SIZE, CELL_BORDER_RADIUS);

                    // Th√™m icon
                    const icon = this.createIcon(this.type);
                    icon.position.set(CELL_SIZE / 2, CELL_SIZE / 2);
                    newGraphic.addChild(icon);
                }

                this.graphic = newGraphic;
                return newGraphic;
            }

            createIcon(type) {
                if (CONFIG.USE_BASE64_ICONS) {
                    const iconBase64 = CONFIG.CELL_ICONS_BASE64[type];
                    const texture = PIXI.Texture.from(iconBase64);
                    const sprite = new PIXI.Sprite(texture);

                    const iconSize = CONFIG.CELL_SIZE * 0.6;
                    sprite.width = iconSize;
                    sprite.height = iconSize;
                    sprite.anchor.set(0.5, 0.5);

                    return sprite;
                } else {
                    const text = new PIXI.Text(CONFIG.CELL_ICONS_EMOJI[type], {
                        fontSize: 28,
                        fill: '#ffffff'
                    });
                    text.anchor.set(0.5, 0.5);
                    return text;
                }
            }
            
            createGradientTexture(width, height, fromColor, toColor, direction = 'vertical') {
                // 1. T·∫°o canvas t·∫°m
                const canvas = document.createElement('canvas');
                canvas.width = width;
                canvas.height = height;
                const ctx = canvas.getContext('2d');

                // 2. X√°c ƒë·ªãnh h∆∞·ªõng gradient
                let gradient;
                switch (direction) {
                    case 'horizontal':
                        gradient = ctx.createLinearGradient(0, 0, width, 0);
                        break;
                    case 'diagonal':
                        gradient = ctx.createLinearGradient(0, 0, width, height);
                        break;
                    case 'vertical':
                    default:
                        gradient = ctx.createLinearGradient(0, 0, 0, height);
                        break;
                }

                // 3. Th√™m m√†u
                gradient.addColorStop(0, fromColor);
                gradient.addColorStop(1, toColor);

                // 4. Fill canvas
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, width, height);

                // 5. T·∫°o base texture v√† cho ph√©p reuse
                const baseTexture = PIXI.BaseTexture.from(canvas, {
                    scaleMode: PIXI.SCALE_MODES.LINEAR, // m∆∞·ª£t h∆°n
                });

                // 6. Tr·∫£ v·ªÅ texture
                return new PIXI.Texture(baseTexture);
            }


            setType(type) {
                this.type = type;
                return this.render();
            }

            getGraphic() {
                if (!this.graphic) {
                    this.render();
                }
                return this.graphic;
            }
        }

        // ==================== BLOCK CLASS ====================
        class GameBlock {
            constructor(cells) {
                this.cells = cells;
                this.cellObjects = [];
            }

            static generateWithRandomTypes(shapeIndex) {
                const { BLOCK_SHAPES, CELL_COLORS } = CONFIG;
                const shape = BLOCK_SHAPES[shapeIndex];
                const cells = [];

                shape.forEach(([x, y]) => {
                    const type = Math.floor(Math.random() * CELL_COLORS.length);
                    cells.push({ x, y, type });
                });

                return new GameBlock(cells);
            }

            render(container, offsetX = 0, offsetY = 0) {
                const { CELL_SIZE } = CONFIG;
                this.cellObjects = [];

                this.cells.forEach(({ x, y, type }) => {
                    const cell = new GameCell(type);
                    const graphic = cell.render();
                    graphic.position.set(offsetX + x * CELL_SIZE, offsetY + y * CELL_SIZE);
                    container.addChild(graphic);
                    this.cellObjects.push({ cell, graphic, x, y, type });
                });

                return this.cellObjects;
            }

            getCells() {
                return this.cells;
            }
        }

        // ==================== GAME CLASS ====================
        class PuzzleBlockGame {
            constructor() {
                this.initPixi();
                this.initBoard();
                this.initGame();
                this.setupEvents();
            }

            initPixi() {
                const { BOARD_COLS, BOARD_ROWS, CELL_SIZE } = CONFIG;
                const canvasWidth = CELL_SIZE * BOARD_COLS + 20;
                const canvasHeight = CELL_SIZE * BOARD_ROWS + 150;

                this.app = new PIXI.Application({
                    width: canvasWidth,
                    height: canvasHeight,
                    backgroundColor: 0xc2185b,
                    antialias: true,
                    resolution: window.devicePixelRatio || 1
                });

                const container = document.getElementById('gameCanvas');
                container.appendChild(this.app.view);

                this.resizeCanvas();
                window.addEventListener('resize', () => this.resizeCanvas());

                this.drawBoardBackground();

                this.boardContainer = new PIXI.Container();
                this.boardContainer.position.set(10, 10);
                this.app.stage.addChild(this.boardContainer);

                this.blocksContainer = new PIXI.Container();
                // T√≠nh ƒë√∫ng t·ªïng chi·ªÅu r·ªông h√†ng preview theo board (3 √¥ 100 + 2 kho·∫£ng 20 = 340)
                const previewCount = 3;
                const slotWidth = 100;
                const slotGap = 20;
                const totalBlocksWidth = previewCount * slotWidth + (previewCount - 1) * slotGap;

                // Canh gi·ªØa theo board thay v√¨ theo to√†n b·ªô canvas
                const boardWidth = CONFIG.BOARD_COLS * CONFIG.CELL_SIZE;
                const boardX = this.boardContainer.x;
                this.blocksContainer.position.set(
                    boardX + (boardWidth - totalBlocksWidth) / 2,
                    CONFIG.CELL_SIZE * CONFIG.BOARD_ROWS + 20
                );
                this.app.stage.addChild(this.blocksContainer);

                this.app.stage.interactive = true;
            }

            resizeCanvas() {
                const container = document.getElementById('gameContainer');
                const canvas = this.app.view;
                const aspectRatio = this.app.renderer.width / this.app.renderer.height;

                let width = container.clientWidth;
                let height = container.clientHeight;

                if (width / height > aspectRatio) {
                    width = height * aspectRatio;
                } else {
                    height = width / aspectRatio;
                }

                canvas.style.width = width + 'px';
                canvas.style.height = height + 'px';
            }

            drawBoardBackground() {
                const { BOARD_COLS, BOARD_ROWS, CELL_SIZE, CELL_BORDER_WIDTH } = CONFIG;
                const bg = new PIXI.Graphics();

                bg.lineStyle(8, 0x3d2817);
                bg.drawRoundedRect(
                    CELL_BORDER_WIDTH *2, 
                    CELL_BORDER_WIDTH *2, 
                    CELL_SIZE * BOARD_COLS + CELL_BORDER_WIDTH*2, 
                    CELL_SIZE * BOARD_ROWS + CELL_BORDER_WIDTH*2, 
                    15
                );
                
                this.app.stage.addChildAt(bg, 0);
            }

            initBoard() {
                const { BOARD_COLS, BOARD_ROWS } = CONFIG;
                this.board = Array(BOARD_ROWS).fill(null).map(() => Array(BOARD_COLS).fill(null));
                this.cellSprites = [];

                for (let r = 0; r < BOARD_ROWS; r++) {
                    for (let c = 0; c < BOARD_COLS; c++) {
                        const cell = new GameCell();
                        cell.graphic = cell.render();
                        cell.graphic.position.set(c * CONFIG.CELL_SIZE, r * CONFIG.CELL_SIZE);
                        this.boardContainer.addChild(cell.graphic);
                        this.board[r][c] = cell;
                        this.cellSprites.push({ cell, graphic: cell.graphic, row: r, col: c });
                    }
                }
            }

            initGame() {
                this.score = 0;
                this.level = 1;
                this.currentBlocks = [];
                this.draggedBlock = null;
                // Track c√°c √¥ board ƒë√£ highlight ƒë·ªÉ restore m·ªói frame
                this.prevHighlightedBoardCells = new Set();
                
                this.generateNewBlocks();
                this.renderBlockPreviews();
                this.updateUI();
            }

            setupEvents() {
                this.app.stage.on('pointermove', (e) => this.onPointerMove(e));
                this.app.stage.on('pointerup', (e) => this.onPointerUp(e));
                this.app.stage.on('pointerupoutside', (e) => this.onPointerUp(e));
            }

            generateNewBlocks() {
                const { BLOCK_SHAPES } = CONFIG;
                this.currentBlocks = [];

                for (let i = 0; i < 3; i++) {
                    const shapeIdx = Math.floor(Math.random() * BLOCK_SHAPES.length);
                    this.currentBlocks.push(GameBlock.generateWithRandomTypes(shapeIdx));
                }
            }

            renderBlockPreviews() {
                // T·∫°o wrapper m·ªôt l·∫ßn, sau ƒë√≥ ch·ªâ c·∫≠p nh·∫≠t n·ªôi dung block b√™n trong
                if (this.blocksContainer.children.length === 0) {
                    this.currentBlocks.forEach((block, blockIndex) => {
                        const blockGroup = this.createBlockPreview(block, blockIndex);
                        blockGroup.interactive = !!block;
                        blockGroup.buttonMode = !!block;
                        blockGroup.removeAllListeners();
                        if (block) {
                            blockGroup.on('pointerdown', (e) => this.startDragBlock(e, block, blockIndex));
                        }
                        this.blocksContainer.addChild(blockGroup);
                    });
                    return;
                }
                        // C·∫≠p nh·∫≠t n·ªôi dung c·ªßa c√°c wrapper ƒë√£ t·ªìn t·∫°i
                this.currentBlocks.forEach((block, blockIndex) => {
                    const blockGroup = this.blocksContainer.children[blockIndex];
                    if (!blockGroup) return;

                    // X√≥a cellGroup c≈© n·∫øu c√≥ (gi·ªØ nguy√™n wrapper v√† bg)
                    if (blockGroup.cellGroup) {
                        blockGroup.removeChild(blockGroup.cellGroup);
                        blockGroup.cellGroup.destroy({ children: true });
                        blockGroup.cellGroup = null;
                    }

                    blockGroup.interactive = !!block;
                    blockGroup.buttonMode = !!block;
                    blockGroup.removeAllListeners();

                    if (!block) {
                        // Slot tr·ªëng: gi·ªØ wrapper/bg, disable t∆∞∆°ng t√°c
                        blockGroup.alpha = 1;
                        return;
                    }

                    // T·∫°o cellGroup m·ªõi v√† render block v√†o wrapper
                    const cellGroup = new PIXI.Container();
                    cellGroup.scale.set(0.5, 0.5);

                    let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
                    block.cells.forEach(({ x, y }) => {
                        minX = Math.min(minX, x);
                        minY = Math.min(minY, y);
                        maxX = Math.max(maxX, x);
                        maxY = Math.max(maxY, y);
                    });
                    const blockWidth = (maxX - minX + 1) * CONFIG.CELL_SIZE * 0.5;
                    const blockHeight = (maxY - minY + 1) * CONFIG.CELL_SIZE * 0.5;
                    const offsetX = (100 - blockWidth) / 2;
                    const offsetY = (100 - blockHeight) / 2;

                    cellGroup.position.set(offsetX, offsetY);
                    block.render(cellGroup, -minX * CONFIG.CELL_SIZE, -minY * CONFIG.CELL_SIZE);

                    blockGroup.cellGroup = cellGroup;
                    blockGroup.addChild(cellGroup);

                    blockGroup.on('pointerdown', (e) => this.startDragBlock(e, block, blockIndex));
                });
    
            }

            createBlockPreview(block, index) {
              // Wrapper c·ªë ƒë·ªãnh + n·ªÅn
                const blockGroup = new PIXI.Container();
                blockGroup.position.set(index * 120, 0);

                const bg = new PIXI.Graphics();
                bg.beginFill(0x5d3a5a);
                bg.lineStyle(3, 0x3d2817);
                bg.drawRoundedRect(0, 0, 100, 100, 12);
                bg.endFill();
                blockGroup.addChild(bg);

                // N·∫øu c√≥ block ban ƒë·∫ßu, render n·ªôi dung v√†o cellGroup (ƒë·ªÉ l·∫ßn ƒë·∫ßu hi·ªÉn th·ªã)
                if (block) {
                    const cellGroup = new PIXI.Container();
                    cellGroup.scale.set(0.5, 0.5);

                    let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
                    block.cells.forEach(({ x, y }) => {
                        minX = Math.min(minX, x);
                        minY = Math.min(minY, y);
                        maxX = Math.max(maxX, x);
                        maxY = Math.max(maxY, y);
                    });
                    const blockWidth = (maxX - minX + 1) * CONFIG.CELL_SIZE * 0.5;
                    const blockHeight = (maxY - minY + 1) * CONFIG.CELL_SIZE * 0.5;
                    const offsetX = (100 - blockWidth) / 2;
                    const offsetY = (100 - blockHeight) / 2;

                    cellGroup.position.set(offsetX, offsetY);
                    block.render(cellGroup, -minX * CONFIG.CELL_SIZE, -minY * CONFIG.CELL_SIZE);

                    blockGroup.cellGroup = cellGroup;
                    blockGroup.addChild(cellGroup);
                }

                return blockGroup;
            }

            startDragBlock(e, block, blockIndex) {
                this.draggedBlock = {
                    block,
                    blockIndex,
                    startPos: { x: e.data.global.x, y: e.data.global.y },
                    dragGraphic: null,
                    dragHighlightLayer: null  // Th√™m layer highlight cho block k√©o
                };

                e.currentTarget.alpha = 0.5;
                e.currentTarget.dragBlockIndex = blockIndex;

                this.onPointerMove(e);
            }

            onPointerMove(e) {
                if (!this.draggedBlock) return;

                const { CELL_SIZE } = CONFIG;
                const pos = e.data.global;

                if (!this.draggedBlock.dragGraphic) {
                    this.draggedBlock.dragGraphic = new PIXI.Container();
                    this.draggedBlock.dragGraphic.scale.set(1, 1);
                    this.app.stage.addChild(this.draggedBlock.dragGraphic);

                    let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
                    this.draggedBlock.block.cells.forEach(({ x, y }) => {
                        minX = Math.min(minX, x);
                        minY = Math.min(minY, y);
                        maxX = Math.max(maxX, x);
                        maxY = Math.max(maxY, y);
                    });

                    const width = (maxX - minX + 1) * CELL_SIZE;
                    const height = (maxY - minY + 1) * CELL_SIZE;
                    this.draggedBlock.dragBounds = { minX, minY, width, height };
                    this.draggedBlock.dragCells = [];

                    this.draggedBlock.block.cells.forEach(({ x, y, type }) => {
                        const cell = new GameCell(type);
                        const graphic = cell.render();
                        graphic.position.set((x - minX) * CELL_SIZE, (y - minY) * CELL_SIZE);
                        this.draggedBlock.dragGraphic.addChild(graphic);
                        this.draggedBlock.dragCells.push({ dx: x, dy: y, cell, graphic });
                    });

                    // Anchor bottom-center b·∫±ng pivot
                    this.draggedBlock.dragGraphic.pivot.set(width / 2, height);
                }

                // ƒê·∫∑t v·ªã tr√≠: bottom-center t·∫°i v·ªã tr√≠ ng√≥n tay, l·ªách l√™n 10px
                this.draggedBlock.dragGraphic.position.set(pos.x, pos.y - 10);
                this.updateBoardHighlight(pos);
            }

            updateBoardHighlight(pos) {
                const { CELL_SIZE, BOARD_COLS, BOARD_ROWS } = CONFIG;
                const boardWorldPos = this.boardContainer.toGlobal({ x: 0, y: 0 });

                const topLeftWorld = this.draggedBlock.dragGraphic.toGlobal(new PIXI.Point(0, 0));
                const localPos = this.boardContainer.toLocal(topLeftWorld);
                localPos.x+=CELL_SIZE/2;
                localPos.y+=CELL_SIZE/2;

                const startC = Math.floor(localPos.x  / CELL_SIZE);
                const startR = Math.floor(localPos.y / CELL_SIZE);

                // T·∫°o/clear layer highlight n·∫±m tr√™n board
                if (!this.boardHighlightLayer) {
                    this.boardHighlightLayer = new PIXI.Container();
                    this.boardContainer.addChild(this.boardHighlightLayer);
                } else {
                    this.boardHighlightLayer.removeChildren();
                }

                // Revert cell style v·ªÅ m·∫∑c ƒë·ªãnh cho c√°c √¥ ƒë√£ highlight ·ªü frame tr∆∞·ªõc
                if (this.prevHighlightedBoardCells && this.prevHighlightedBoardCells.size) {
                    this.prevHighlightedBoardCells.forEach(key => {
                        const [r, c] = key.split(',').map(Number);
                        const cell = this.board[r][c];
                        if (cell.type === -1) return; // √¥ tr·ªëng kh√¥ng c·∫ßn render
                        const newGraphic = cell.render();
                        // ƒê·∫£m b·∫£o graphic m·ªõi gi·ªØ ƒë√∫ng v·ªã tr√≠ tr√™n l∆∞·ªõi
                        newGraphic.position.set(c * CONFIG.CELL_SIZE, r * CONFIG.CELL_SIZE);
                        const spriteData = this.cellSprites.find(s => s.row === r && s.col === c);
                        if (spriteData && spriteData.graphic.parent) {
                            const index = spriteData.graphic.parent.children.indexOf(spriteData.graphic);
                            this.boardContainer.removeChild(spriteData.graphic);
                            this.boardContainer.addChildAt(newGraphic, index);
                            spriteData.graphic = newGraphic;
                            cell.graphic = newGraphic;
                        }
                    });
                    this.prevHighlightedBoardCells.clear();
                }

                // Ki·ªÉm tra c√≥ th·ªÉ ƒë·∫∑t kh√¥ng
                let canPlace = true;
                const placingCells = [];
                this.draggedBlock.dragCells.forEach(dc => {
                    const r = startR + Math.floor(dc.graphic.position.y / CELL_SIZE);
                    const c = startC + Math.floor(dc.graphic.position.x / CELL_SIZE);
                    const type = dc.cell.type;
                    if (r < 0 || r >= BOARD_ROWS || c < 0 || c >= BOARD_COLS || this.board[r][c].type !== -1) {
                        canPlace = false;
                    }
                    placingCells.push({ r, c, type, dx: dc.dx, dy: dc.dy });
                });

                // Overlay: highlight ch·ªó tr·ªëng h·ª£p l·ªá/kh√¥ng h·ª£p l·ªá ƒë·ªÉ b√°o tr·∫°ng th√°i ƒë·∫∑t
                placingCells.forEach(({ r, c }) => {
                    if (r < 0 || r >= BOARD_ROWS || c < 0 || c >= BOARD_COLS) return;

                    const isEmpty = this.board[r][c].type === -1;
                    const highlight = new PIXI.Graphics();
                    highlight.beginFill(isEmpty ? 0x00FF00 : 0xFF0000, 0.3);
                    highlight.drawRect(0, 0, CELL_SIZE, CELL_SIZE);
                    highlight.endFill();

                    // ƒê·∫∑t highlight theo to·∫° ƒë·ªô local c·ªßa boardContainer
                    highlight.position.set(c * CELL_SIZE, r * CELL_SIZE);
                    this.boardHighlightLayer.addChild(highlight);
                });

                // N·∫øu ƒë·∫∑t ƒë∆∞·ª£c ‚Üí t√≠nh nh√≥m s·∫Ω b·ªã x√≥a
                if (canPlace) {
                    const tempBoard = this.board.map(row => row.map(cell => ({ type: cell.type })));
                    placingCells.forEach(({ r, c, type }) => {
                        tempBoard[r][c].type = type;
                    });

                    const toBeRemoved = new Set();

                    placingCells.forEach(({ r, c }) => {
                        if (tempBoard[r][c].type === -1) return;
                        const group = this.getConnectedGroupTemp(tempBoard, r, c);
                        if (group.length >= 3) {
                            group.forEach(([gr, gc]) => toBeRemoved.add(`${gr},${gc}`));
                        }
                    });

                    // CH·ªà HIGHLIGHT √î ƒê√É C√ì ITEM (tr√™n board) ‚Üí ƒë·ªïi background + padding sang m√†u xanh
                    toBeRemoved.forEach(key => {
                        const [r, c] = key.split(',').map(Number);
                        const originalCell = this.board[r][c];

                        if (originalCell.type === -1) return;

                        const newGraphic = originalCell.renderHighlightGreen();
                        // ƒê·∫£m b·∫£o graphic m·ªõi gi·ªØ ƒë√∫ng v·ªã tr√≠ tr√™n l∆∞·ªõi
                        newGraphic.position.set(c * CONFIG.CELL_SIZE, r * CONFIG.CELL_SIZE);
                        const spriteData = this.cellSprites.find(s => s.row === r && s.col === c);
                        if (spriteData && spriteData.graphic.parent) {
                            const index = spriteData.graphic.parent.children.indexOf(spriteData.graphic);
                            this.boardContainer.removeChild(spriteData.graphic);
                            this.boardContainer.addChildAt(newGraphic, index);
                            spriteData.graphic = newGraphic;
                            originalCell.graphic = newGraphic;
                        }

                        // L∆∞u l·∫°i ƒë·ªÉ l·∫ßn sau revert
                        this.prevHighlightedBoardCells.add(key);
                    });

                    // ƒê·ªîI M√ÄU √î TRONG BLOCK K√âO (re-render graphic c·ªßa t·ª´ng cell)
                    if (this.draggedBlock.dragCells && this.draggedBlock.dragCells.length) {
                        this.draggedBlock.dragCells.forEach(dc => {
                            const r = startR + Math.floor(dc.graphic.position.y / CELL_SIZE);
                            const c = startC + Math.floor(dc.graphic.position.x / CELL_SIZE);
                            const key = `${r},${c}`;
                            const shouldHighlight = toBeRemoved.has(key);

                            const newGraphic = shouldHighlight ? dc.cell.renderHighlightGreen() : dc.cell.render();
                            newGraphic.position.copyFrom(dc.graphic.position);

                            const parent = dc.graphic.parent;
                            const index = parent.children.indexOf(dc.graphic);
                            parent.removeChild(dc.graphic);
                            parent.addChildAt(newGraphic, index);
                            dc.graphic = newGraphic;
                        });
                    }

                    // Kh√¥ng v·∫Ω overlay tr√™n block k√©o ƒë·ªÉ tr√°nh ƒë√® l√™n block
                }
                else {
                    // Kh√¥ng ƒë·∫∑t ƒë∆∞·ª£c ‚Üí revert √¥ trong block v·ªÅ m√†u th∆∞·ªùng
                    if (this.draggedBlock?.dragCells && this.draggedBlock.dragCells.length) {
                        this.draggedBlock.dragCells.forEach(dc => {
                            const newGraphic = dc.cell.render();
                            newGraphic.position.copyFrom(dc.graphic.position);
                            const parent = dc.graphic.parent;
                            const index = parent.children.indexOf(dc.graphic);
                            parent.removeChild(dc.graphic);
                            parent.addChildAt(newGraphic, index);
                            dc.graphic = newGraphic;
                        });
                    }
                }
            }
            getConnectedGroupTemp(tempBoard, startR, startC) {
                const { BOARD_ROWS, BOARD_COLS } = CONFIG;
                const type = tempBoard[startR][startC].type;
                const visited = new Set();
                const group = [];
                const stack = [[startR, startC]];

                while (stack.length > 0) {
                    const [r, c] = stack.pop();
                    const key = `${r},${c}`;
                    if (visited.has(key)) continue;
                    visited.add(key);

                    if (r >= 0 && r < BOARD_ROWS && c >= 0 && c < BOARD_COLS && tempBoard[r][c].type === type) {
                        group.push([r, c]);
                        stack.push([r + 1, c], [r - 1, c], [r, c + 1], [r, c - 1]);
                    }
                }
                return group;
            }

            onPointerUp(e) {
                 if (!this.draggedBlock) return;
                if (this.draggedBlock.dragGraphic) {
                    this.app.stage.removeChild(this.draggedBlock.dragGraphic);
                    this.draggedBlock.dragGraphic = null;
                }
                if (this.draggedBlock.dragHighlightLayer) {
                    this.draggedBlock.dragHighlightLayer = null;
                }
                const { BOARD_COLS, BOARD_ROWS, CELL_SIZE } = CONFIG;
                const pos = e.data.global;

                const { width = 0, height = 0 } = this.draggedBlock.dragBounds || {};
                const adjustedPos = new PIXI.Point(pos.x - width / 2, (pos.y - 10) - height);
                const localPos = this.boardContainer.toLocal(adjustedPos);

                const blockGroup = this.blocksContainer.children[this.draggedBlock.blockIndex];
                if (blockGroup) blockGroup.alpha = 1;

                if (this.draggedBlock.dragGraphic) {
                    this.app.stage.removeChild(this.draggedBlock.dragGraphic);
                }

                if (this.boardHighlightLayer) {
                    this.boardHighlightLayer.removeChildren();
                }

                /// Revert to√†n b·ªô √¥ board ƒë√£ highlight v·ªÅ m·∫∑c ƒë·ªãnh sau khi th·∫£ chu·ªôt
        if (this.prevHighlightedBoardCells && this.prevHighlightedBoardCells.size) {
            this.prevHighlightedBoardCells.forEach(key => {
                const [r, c] = key.split(',').map(Number);
                    const cell = this.board[r][c];
                    if (cell.type === -1) return;

                    const newGraphic = cell.render();
                    // FIX: set v·ªã tr√≠ ƒë√∫ng theo l∆∞·ªõi
                    newGraphic.position.set(c * CONFIG.CELL_SIZE, r * CONFIG.CELL_SIZE);

                    const spriteData = this.cellSprites.find(s => s.row === r && s.col === c);
                    if (spriteData && spriteData.graphic.parent) {
                        const index = spriteData.graphic.parent.children.indexOf(spriteData.graphic);
                        this.boardContainer.removeChild(spriteData.graphic);
                        this.boardContainer.addChildAt(newGraphic, index);
                        spriteData.graphic = newGraphic;
                        cell.graphic = newGraphic;
                    }
                });
                this.prevHighlightedBoardCells.clear();
            }
                localPos.x+=CELL_SIZE/2;
                 localPos.y += CELL_SIZE/2;
                if (localPos.x >= 0 && localPos.x < CELL_SIZE * BOARD_COLS &&
                    localPos.y >= 0 && localPos.y < CELL_SIZE * BOARD_ROWS) {
                    this.tryPlaceBlock(this.draggedBlock.block, localPos.x, localPos.y, this.draggedBlock.blockIndex);
                }

                this.draggedBlock = null;
            }

            tryPlaceBlock(block, x, y, blockIndex) {
                      const { CELL_SIZE, BOARD_COLS, BOARD_ROWS } = CONFIG;
                    const startC = Math.floor(x / CELL_SIZE);
                    const startR = Math.floor(y / CELL_SIZE);

                    let canPlace = true;
                    for (let { x: dx, y: dy } of block.cells) {
                        const r = startR + dy;
                        const c = startC + dx;
                        if (r < 0 || r >= BOARD_ROWS || c < 0 || c >= BOARD_COLS || this.board[r][c].type !== -1) {
                            canPlace = false;
                            break;
                        }
                    }

                    if (!canPlace) return;

                    for (let { x: dx, y: dy, type } of block.cells) {
                        const r = startR + dy;
                        const c = startC + dx;
                        this.board[r][c].setType(type);
                        this.updateCellGraphic(r, c);
                    }

                    // Thay v√¨ splice (l√†m shift v·ªã tr√≠ c√°c slot), gi·ªØ slot c·ªë ƒë·ªãnh v√† clear n·ªôi dung
                    this.currentBlocks[blockIndex] = null;

                    // N·∫øu c·∫£ 3 slot ƒë·ªÅu tr·ªëng -> t·∫°o b·ªô block m·ªõi
                    if (this.currentBlocks.every(b => !b)) {
                        this.generateNewBlocks();
                    }

                    this.checkMatches();
                    this.renderBlockPreviews();
                    this.updateUI();
    
            }

            updateCellGraphic(row, col) {
                const cell = this.board[row][col];
                const newGraphic = cell.render();
                newGraphic.position.set(col * CONFIG.CELL_SIZE, row * CONFIG.CELL_SIZE);

                const spriteData = this.cellSprites.find(s => s.row === row && s.col === col);
                if (spriteData && spriteData.graphic.parent) {
                    const index = spriteData.graphic.parent.children.indexOf(spriteData.graphic);
                    this.boardContainer.removeChild(spriteData.graphic);
                    this.boardContainer.addChildAt(newGraphic, index);
                    spriteData.graphic = newGraphic;
                    cell.graphic = newGraphic;
                }
            }

            checkMatches() {
                const { BOARD_ROWS, BOARD_COLS } = CONFIG;
                let matched = new Set();

                for (let r = 0; r < BOARD_ROWS; r++) {
                    for (let c = 0; c < BOARD_COLS; c++) {
                        if (this.board[r][c].type === -1) continue;

                        const group = this.getConnectedGroup(r, c);
                        if (group.length >= 3) {
                            group.forEach(([gr, gc]) => matched.add(`${gr},${gc}`));
                        }
                    }
                }

                if (matched.size > 0) {
                    matched.forEach(key => {
                        const [r, c] = key.split(',').map(Number);
                        this.board[r][c].setType(-1);
                        this.updateCellGraphic(r, c);
                        this.score++;
                    });

                    this.updateUI();
                    setTimeout(() => this.checkMatches(), 200);
                }
            }

            getConnectedGroup(startR, startC) {
                const { BOARD_ROWS, BOARD_COLS } = CONFIG;
                const type = this.board[startR][startC].type;
                const visited = new Set();
                const group = [];
                const stack = [[startR, startC]];

                while (stack.length > 0) {
                    const [r, c] = stack.pop();
                    const key = `${r},${c}`;

                    if (visited.has(key)) continue;
                    visited.add(key);

                    if (r >= 0 && r < BOARD_ROWS && c >= 0 && c < BOARD_COLS &&
                        this.board[r][c].type === type) {
                        group.push([r, c]);
                        stack.push([r + 1, c], [r - 1, c], [r, c + 1], [r, c - 1]);
                    }
                }

                return group;
            }

            updateUI() {
                document.getElementById('score').textContent = this.score;

                for (let i = 1; i < CONFIG.LEVEL_MILESTONES.length; i++) {
                    if (this.score >= CONFIG.LEVEL_MILESTONES[i]) {
                        this.level = i + 1;
                    }
                }
                document.getElementById('level').textContent = this.level;

                const currentMilestone = CONFIG.LEVEL_MILESTONES[this.level - 1] || 0;
                const nextMilestone = CONFIG.LEVEL_MILESTONES[this.level] || currentMilestone + 500;
                const progress = ((this.score - currentMilestone) / (nextMilestone - currentMilestone)) * 100;

                document.getElementById('prevMilestone').textContent = currentMilestone + 'K';
                document.getElementById('nextMilestone').textContent = nextMilestone + 'K';
                document.getElementById('currentScore').textContent = this.score.toLocaleString();

                const progressPercent = Math.min(Math.max(progress, 0), 100);
                const greenPercent = Math.min(progressPercent, 50) * 2;
                const bluePercent = Math.max(0, (progressPercent - 50) * 2);
                const blackPercent = 100 - greenPercent - bluePercent;

                document.getElementById('progressGreen').style.width = greenPercent + '%';
                document.getElementById('progressBlack').style.width = blackPercent + '%';
                document.getElementById('progressBlue').style.width = bluePercent + '%';
            }
        }

        new PuzzleBlockGame();
    </script>
</body>

</html>
